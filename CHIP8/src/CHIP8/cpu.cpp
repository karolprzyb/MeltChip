#include "allInclude.h"
instructions::instructions()
{
	//THIS SHOULD NEVER BE USED
}
instructions::instructions(display *displayPassed, stack *stackPassed, registers *cpuPassed, memory *memoryPassed, controls *contr)
{
	mainControls = contr;
	displayMain = displayPassed;
	stackMain = stackPassed;
	memoryMain = memoryPassed;
	cpu = cpuPassed;
	op.hi = memoryMain->mem[cpu->PC];
	op.lo = memoryMain->mem[cpu->PC + 1];
	#ifdef LOGGING_CHIP8
	extern log mainLog;
	mainLog.message = "Init instructions\n";
	mainLog.writeMessage();
	#endif
}
void instructions::replaceInstruct()
{
	op.hi = memoryMain->mem[cpu->PC];
	op.lo = memoryMain->mem[cpu->PC + 1];
	#ifdef DEBUG_INSTRUCT_LOGGING
	extern log mainLog;
	mainLog.message = "Instruction replaced\n";
	mainLog.writeMessage();
	#endif
}
void instructions::interpret()
{
	#ifdef DEBUG_INSTRUCT_LOGGING
	extern log mainLog;
	std::ostringstream appendint;
	appendint << std::hex << op.whole;
	mainLog.message = "Current instruction:" + appendint.str() + "\n";
	mainLog.writeMessage();
	#endif
	switch(op.hi & 0xF0)
	{
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	case 0x0:
		switch(op.lo)
		{
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		case 0xEE:
			cpu->PC = stackMain->pop();
		break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		case 0xE0:
			displayMain->reset();
		break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		default:
		//jump to machine code routine at nnn where nnn are the last 4 nybbles of the instruction not implemented in modern interpreters
		break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		}
	break;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	case 0x10:
		op.hi &= 0x0F;
		cpu->PC = op.whole - 0x02;
	break;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	case 0x20:
		op.hi &= 0x0F;
		stackMain->push(cpu->PC);
		cpu->PC = op.whole - 2;
	break;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	case 0x30:
		if(cpu->V[op.hi & 0x0F] == op.lo)
			cpu->PC += 2;
	break;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	case 0x40:
		if(cpu->V[op.hi & 0x0F] != op.lo)
			cpu->PC += 2;
	break;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	case 0x50:
		if(cpu->V[op.hi & 0x0F] == cpu->V[op.lo >> 4])
			cpu->PC += 2;
	break;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	case 0x60:
		cpu->V[op.hi & 0x0F] = op.lo;
	break;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	case 0x70:
		cpu->V[op.hi & 0x0F] += op.lo;
	break;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	case 0x80:
		switch(op.lo & 0x0F)
		{
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		case 0x0:
			cpu->V[op.hi & 0x0F] = cpu->V[op.lo >> 4];
		break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		case 0x1:
			cpu->V[op.hi & 0x0F] |= cpu->V[op.lo >> 4];
		break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		case 0x2:
			cpu->V[op.hi & 0x0F] &= cpu->V[op.lo >> 4];
		break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		case 0x3:
			cpu->V[op.hi & 0x0F] ^= cpu->V[op.lo >> 4];
		break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		case 0x4:
			if(((short int)cpu->V[op.hi & 0x0F] + (short int)cpu->V[op.lo >> 4]) > (short int)255)
				cpu->V[0xF] = 1;
			else
				cpu->V[0xF] = 0;
			cpu->V[op.hi & 0x0F] += cpu->V[op.lo >> 4];
		break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		case 0x5:
			if(cpu->V[op.hi & 0x0F] >= cpu->V[op.lo >> 4])
			{
				cpu->V[0xF] = 1;
				cpu->V[op.hi & 0x0F] -= cpu->V[op.lo >> 4];
			}
			else
			{
				cpu->V[0xF] = 0;
				cpu->V[op.hi & 0x0F] = 256 - (cpu->V[op.lo >> 4] - cpu->V[op.hi & 0x0F]);
			}
		break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		case 0x6:
			if((cpu->V[op.hi & 0x0F] & 0x01) == 0x01)
				cpu->V[0xF] = 1;
			else
				cpu->V[0xF] = 0;
			cpu->V[op.hi & 0x0F] /= 2;
		break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		case 0x7:
			if(cpu->V[op.hi & 0x0F] <= cpu->V[op.lo >> 4])
			{
				cpu->V[0xF] = 1;
				cpu->V[op.hi & 0x0F] = cpu->V[op.lo >> 4] - cpu->V[op.hi & 0x0F];
			}
			else
			{
				cpu->V[0xF] = 0;
				cpu->V[op.hi & 0x0F] = 256 - (cpu->V[op.hi & 0x0F] - cpu->V[op.lo >> 4]);
			}
		break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		case 0xE:
			if((cpu->V[op.hi & 0x0F] & 0x80) == 0x80)
				cpu->V[0xF] = 1;
			else
				cpu->V[0xF] = 0;
			cpu->V[op.hi & 0x0F] *= 2;
		break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		}
	break;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	case 0x90:
		if(cpu->V[op.hi & 0x0F] != cpu->V[op.lo >> 4])
			cpu->PC += 2;
	break;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	case 0xA0:
		op.hi &= 0x0F;
		cpu->I = op.whole;
	break;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	case 0xB0:
		op.hi &= 0x0F;
		cpu->PC = op.whole + cpu->V[0x00];
	break;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	case 0xC0:
		randNum.refresh();
		cpu->V[op.hi & 0x0F] = randNum.num & op.lo;
	break;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	case 0xD0:
		cpu->V[0x0F] = 0;
		{                                            //This bracket is simply to limit yCoord's scope to this opCode
		#ifdef DEBUG_INSTRUCT_LOGGING
		extern log mainLog;
		mainLog.message = "DRAWING...\n";
		mainLog.writeMessage();
		#endif
		int yCoord = cpu->V[op.lo >> 4];
		for(int n = 0, I = cpu->I; n < (op.lo & 0x0F); n++, I++)
		{
			int xCoord = cpu->V[op.hi & 0x0F];
			if((displayMain->buffer_64_32[xCoord][yCoord + n] == 1) && ((memoryMain->mem[I] & 0x80) == 0x80))
			{
				cpu->V[0x0F] = 1;
				break;
			}
			xCoord++;
			if(xCoord > 63)
				xCoord = 0;
			if((displayMain->buffer_64_32[xCoord][yCoord + n] == 1) && ((memoryMain->mem[I] & 0x40) == 0x40))
			{
				cpu->V[0x0F] = 1;
				break;
			}
			xCoord++;
			if(xCoord > 63)
				xCoord = 0;
			if((displayMain->buffer_64_32[xCoord][yCoord + n] == 1) && ((memoryMain->mem[I] & 0x20) == 0x20))
			{
				cpu->V[0x0F] = 1;
				break;
			}
			xCoord++;
			if(xCoord > 63)
				xCoord = 0;
			if((displayMain->buffer_64_32[xCoord][yCoord + n] == 1) && ((memoryMain->mem[I] & 0x10) == 0x10))
			{
				cpu->V[0x0F] = 1;
				break;
			}
			xCoord++;
			if(xCoord > 63)
				xCoord = 0;
			if((displayMain->buffer_64_32[xCoord][yCoord + n] == 1) && ((memoryMain->mem[I] & 0x08) == 0x08))
			{
				cpu->V[0x0F] = 1;
				break;
			}
			xCoord++;
			if(xCoord > 63)
				xCoord = 0;
			if((displayMain->buffer_64_32[xCoord][yCoord + n] == 1) && ((memoryMain->mem[I] & 0x04) == 0x04))
			{
				cpu->V[0x0F] = 1;
				break;
			}
			xCoord++;
			if(xCoord > 63)
				xCoord = 0;
			if((displayMain->buffer_64_32[xCoord][yCoord + n] == 1) && ((memoryMain->mem[I] & 0x02) == 0x02))
			{
				cpu->V[0x0F] = 1;
				break;
			}
			xCoord++;
			if(xCoord > 63)
				xCoord = 0;
			if((displayMain->buffer_64_32[xCoord][yCoord + n] == 1) && ((memoryMain->mem[I] & 0x01) == 0x01))
			{
				cpu->V[0x0F] = 1;
				break;
			}
		}


		for(int n = 0, I = cpu->I; n < (op.lo & 0x0F); n++, I++)
		{
			int xCoord = cpu->V[op.hi & 0x0F];
			if((memoryMain->mem[I] & 0x80) == 0x80)
				displayMain->buffer_64_32[xCoord][yCoord + n] ^= 0x01;
			xCoord++;
			if(xCoord > 63)
				xCoord = 0;
			if((memoryMain->mem[I] & 0x40) == 0x40)
				displayMain->buffer_64_32[xCoord][yCoord + n] ^= 0x01;
			xCoord++;
			if(xCoord > 63)
				xCoord = 0;
			if((memoryMain->mem[I] & 0x20) == 0x20)
				displayMain->buffer_64_32[xCoord][yCoord + n] ^= 0x01;
			xCoord++;
			if(xCoord > 63)
				xCoord = 0;
			if((memoryMain->mem[I] & 0x10) == 0x10)
				displayMain->buffer_64_32[xCoord][yCoord + n] ^= 0x01;
			xCoord++;
			if(xCoord > 63)
				xCoord = 0;
			if((memoryMain->mem[I] & 0x08) == 0x08)
				displayMain->buffer_64_32[xCoord][yCoord + n] ^= 0x01;
			xCoord++;
			if(xCoord > 63)
				xCoord = 0;
			if((memoryMain->mem[I] & 0x04) == 0x04)
				displayMain->buffer_64_32[xCoord][yCoord + n] ^= 0x01;
			xCoord++;
			if(xCoord > 63)
				xCoord = 0;
			if((memoryMain->mem[I] & 0x02) == 0x02)
				displayMain->buffer_64_32[xCoord][yCoord + n] ^= 0x01;
			xCoord++;
			if(xCoord > 63)
				xCoord = 0;
			if((memoryMain->mem[I] & 0x01) == 0x01)
				displayMain->buffer_64_32[xCoord][yCoord + n] ^= 0x01;
		}
		}                                             //Matching bracket for yCoord's scope
	break;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	case 0xE0:
		switch(op.lo & 0x0F)
		{
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			case 0x0E:
				if(mainControls->key[cpu->V[op.hi & 0x0F]])
					cpu->PC += 0x02;
			break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			case 0x01:
				if(!mainControls->key[cpu->V[op.hi & 0x0F]])
					cpu->PC += 0x02;
			break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		}
	break;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	case 0xF0:
		switch(op.lo)
		{
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			case 0x07:
				cpu->V[op.hi & 0x0F] = cpu->DT;
			break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			case 0x0A:
				cpu->V[op.hi & 0x0F] = mainControls->stallPress();
			break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			case 0x15:
				cpu->DT = cpu->V[op.hi & 0x0F];
			break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			case 0x18:
				cpu->ST = cpu->V[op.hi & 0x0F];
			break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			case 0x1E:
				cpu->I += cpu->V[op.hi & 0x0F];
			break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			case 0x29:
				cpu->I = cpu->V[op.hi & 0x0F] * 0x05;
			break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			case 0x33:
				memoryMain->mem[cpu->I] = cpu->V[op.hi & 0x0F] / 100;
				memoryMain->mem[cpu->I + 1] = (cpu->V[op.hi & 0x0F] % 100) / 10;
				memoryMain->mem[cpu->I + 2] = cpu->V[op.hi & 0x0F] % 10;
			break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			case 0x55:
				for(int begin = cpu->I; cpu->I <= ((op.hi & 0x0F) + begin); cpu->I++)
					memoryMain->mem[cpu->I] = cpu->V[cpu->I - begin];
				cpu->I++;
			break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			case 0x65:
				for(int begin = cpu->I; cpu->I <= ((op.hi & 0x0F) + begin); cpu->I++)
					cpu->V[cpu->I - begin] = memoryMain->mem[cpu->I];
				cpu->I++;
			break;
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		}
	break;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
	cpu->PC += 0x02;
	#ifdef DEBUG_INSTRUCT_LOGGING
	std::ostringstream addthis;
	addthis << cpu->PC << " also op.hi anded: " << std::hex << (op.hi & 0xF0);
	mainLog.message = "Value of PC: " + addthis.str() + "\n";
	mainLog.writeMessage();
	#endif
}
